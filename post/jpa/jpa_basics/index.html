

<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZXLS88');</script>
    

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="Hugo 0.55.3" />
    <link rel="shortcut icon" href="/images/favicon.ico">
    <link href="http://integerous.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Integerous DevLog" />
    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
    
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:700i" rel="stylesheet">
    
    <script src="https://apis.google.com/js/platform.js" async defer>{lang: 'ja'}</script>
    
    <link rel="stylesheet" href="https://yandex.st/highlightjs/8.0/styles/default.min.css">
    <script src="https://yandex.st/highlightjs/8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <link rel="stylesheet" type="text/css" href="/css/single.css">
    <title>&lt;JPA 프로그래밍 기본기 다지기&gt; 내용 정리 | Integerous DevLog</title>
  </head>
  <body>
    
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KZXLS88"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  
    <div id="wrap">
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-126908369-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

      <header class="site-header">
        <div class="site-header-left">
          <a class="site-header-title" href="http://integerous.github.io/">Integerous DevLog</a>
        </div>
      </header>
      <div class="container">
        <div id="main">




<div class="article">
  <header>
    <div class="article-header">
      <h1>&lt;JPA 프로그래밍 기본기 다지기&gt; 내용 정리</h1>
      <div class="article-meta">
        <span class="posttime">2019/04/23</span>

        
        
<div class="tags">
  <ul>
    
    <li>
        <a href="/tags/jpa">JPA</a>
    </li>
    
  </ul>
</div>


      </div>
    </div>
    
  </header>
  <div class="content">
    

<blockquote>
<p><a href="https://www.youtube.com/watch?v=WfrSN9Z7MiA&amp;t=58s">Tacademy 강의</a>를 듣고 내용 정리<br />
강사: 김영한님 (현 우아한형제들 개발자)</p>

<p>이 강의는 김영한님의 두꺼운 JPA 책을 본격적으로 보기 전에 보면 딱 좋을 강의라고 생각한다.<br />
그런데 강의 시간이 길다보니 내용 정리를 하지 않으면 머릿속에 남아있질 않아서 내용을 정리했다.<br />
회사에서 파일럿 프로젝트 하면서 이 정리 글을 보고 또 보고 또 보게 되었다.</p>
</blockquote>

<h2 id="1-sql-중심적인-개발의-문제점">1. SQL 중심적인 개발의 문제점</h2>

<h3 id="1-1-무한-반복-crud">1.1. 무한 반복(CRUD)</h3>

<p>아래와 같은 상황에서 <code>private String tel;</code>필드가 추가되면 모든 tel과 관련된 sql을 다 수정해야 된다.</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">member</span> {
  <span style="color:#8b008b;font-weight:bold">private</span> String memberId;
  <span style="color:#8b008b;font-weight:bold">private</span> String name;

  ...
}</code></pre></div><div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#8b008b;font-weight:bold">INSERT</span> <span style="color:#8b008b;font-weight:bold">INTO</span> MEMBER(MEMBER_ID, NAME) <span style="color:#8b008b;font-weight:bold">VALUES</span>
<span style="color:#8b008b;font-weight:bold">SELECT</span> MEMBER_ID, NAME <span style="color:#8b008b;font-weight:bold">FROM</span> MEMBER M
<span style="color:#8b008b;font-weight:bold">UPDATE</span> MEMBER <span style="color:#8b008b;font-weight:bold">SET</span> ...</code></pre></div>
<h3 id="1-2-entity-신뢰-문제">1.2. Entity 신뢰 문제</h3>

<p>아래와 같은 상황에서 Member객체에 Team, Order, Delivery와 연관을 맺어놨을거라는 보장이 없어서 아래처럼 작성할 수 없다.</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">MemberService</span> {
  ...
  <span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">process</span>(String id) {
    Member member = memberDAO.<span style="color:#658b00">find</span>(id);

    member.<span style="color:#658b00">getTeam</span>(); <span style="color:#228b22">// ???
</span><span style="color:#228b22"></span>    member.<span style="color:#658b00">getOrder</span>().<span style="color:#658b00">getDelivery</span>(); <span style="color:#228b22">// ???
</span><span style="color:#228b22"></span>  }
}</code></pre></div>
<h3 id="1-3-계층형-아키텍쳐에서-진정한-의미의-계층-분할이-어렵다">1.3. 계층형 아키텍쳐에서 진정한 의미의 계층 분할이 어렵다.</h3>

<blockquote>
<p>위에서 처럼 물리적으로는 분할되어있지만 논리적으로는 분할되었는지 모른다.</p>
</blockquote>

<h3 id="1-4-sql에-의존적인-개발을-피하기-어렵다">1.4. SQL에 의존적인 개발을 피하기 어렵다.</h3>

<h2 id="2-패러다임의-불일치">2. 패러다임의 불일치</h2>

<blockquote>
<p>객체 vs 관계형 데이터베이스</p>
</blockquote>

<p>객체를 영구 보관하는 다양한 저장소가 있지만 현실적인 대안은 RDB와 NoSQL 뿐이다.<br />
결국 객체를 SQL로 변환(작성)하여 저장하게 된다.<br />
개발자가 SQL 매퍼일을 너무 많이 한다.</p>

<p>MyBatis Generate 같은 경우에 만들기는 편하지만 유지보수가 잘 안된다.</p>

<h3 id="2-1-객체와-관계형-데이터베이스의-차이">2.1. 객체와 관계형 데이터베이스의 차이</h3>

<ol>
<li>상속</li>

<li><p>연관관계</p>

<ul>
<li>객체의 연관관계에는 방향성이 있다.</li>
<li>테이블의 연관관계는 방향성이 없다.</li>
<li>때문에 보통은 아래와 같이 객체를 테이블에 맞추어 모델링한다.<br /></li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Member</span> {
    String id;      
    Long teamId;  <span style="color:#228b22">//TEAM_ID FK 컬럼 사용
</span><span style="color:#228b22"></span>    String username;
}

<span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Team</span> {
    Long id;  <span style="color:#228b22">//TEAM_ID PK 사용
</span><span style="color:#228b22"></span>    String name;
}</code></pre></div>
<ul>
<li>객체다운 모델링은 아래와 같다.</li>
<li>Member에 Team의 값이 아니라 오브젝트가 있는것이 더 객체지향적인 것이다.<br /></li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Member</span> {
    String id;
    Team team;
    String username;
        
    Team <span style="color:#008b45">getTeam</span>() {
    <span style="color:#8b008b;font-weight:bold">return</span> team;
    }
}

<span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Team</span> {
    Long id;
    String name;
}</code></pre></div>
<ul>
<li>객체는 자유롭게 객체 그래프를 탐색할 수 있어야 한다.</li>
</ul></li>

<li><p>데이터 타입</p></li>

<li><p>데이터 식별 방법</p></li>
</ol>

<blockquote>
<p>객체답게 모델링할수록 매핑 작업만 늘어난다.<br />
객체를 자바 컬렉션에 저장하듯이 DB에 저장할 수는 없을까?</p>
</blockquote>

<h3 id="2-2-orm">2.2. ORM?</h3>

<ul>
<li>Object-relational mapping(객체 관계 매핑)</li>
<li>객체는 객체대로 설계</li>
<li>관계형 데이터베이스는 관계형 데이터베이스대로 설계</li>
<li>ORM 프레임워크가 중간에서 매핑</li>
<li>대중적인 언어에는 대부분 ORM 기술이 존재</li>
</ul>

<h3 id="2-3-jpa는-표준-명세">2.3. JPA는 표준 명세</h3>

<ul>
<li>JPA는 인터페이스의 모음</li>
<li>JPA 표준 명세를 구현한 3가지 구현체

<ul>
<li>Hibernate</li>
<li>EclipseLink</li>
<li>DataNucleus</li>
</ul></li>
<li>우리가 실제로 쓰는 것은 Hibernate라고 보면 된다.(JPA는 인터페이스)</li>
</ul>

<h2 id="3-실습">3. 실습</h2>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Main</span> {
  <span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">main</span>(String[] args) {
  
  EntityManagerFactory emf = Persistence.<span style="color:#658b00">CreateEntityManagerFactory</span>(<span style="color:#cd5555">&#34;hello&#34;</span>);
  <span style="color:#228b22">// persistence.xml persistence-unit의 name이 hello 
</span><span style="color:#228b22"></span>  
  EntityManager em = emf.<span style="color:#658b00">createEntityManager</span>();
  EntityTransaction tx = em.<span style="color:#658b00">getTransaction</span>();
  tx.<span style="color:#658b00">begin</span>();
  
  <span style="color:#228b22">// 작업
</span><span style="color:#228b22"></span>  <span style="color:#8b008b;font-weight:bold">try</span> {
      Member member = <span style="color:#8b008b;font-weight:bold">new</span> Member();
      member.<span style="color:#658b00">setId</span>(100L);
      member.<span style="color:#658b00">setName</span>(<span style="color:#cd5555">&#34;한정수&#34;</span>);

      em.<span style="color:#658b00">persist</span>(member);
      tx.<span style="color:#658b00">commit</span>();
    
  } <span style="color:#8b008b;font-weight:bold">catch</span> (Exception e) {
      tx.<span style="color:#658b00">rollback</span>();
  } <span style="color:#8b008b;font-weight:bold">finally</span> {
      em.<span style="color:#658b00">close</span>();
  }
  
  emf.<span style="color:#658b00">close</span>();</code></pre></div>
<h3 id="3-1-주의점">3.1. 주의점</h3>

<ul>
<li>EntityManagerFactory는 하나만 생성해서 어플리케이션 전체에서 공유</li>
<li>EntityManager는 쓰레드 간에 공유하면 안된다. (사용하고 버려야 한다.)</li>
<li>JPA의 모든 데이터 변경은 트랜잭션 안에서 실행</li>
</ul>

<h2 id="4-데이터베이스-스키마-자동-생성하기">4. 데이터베이스 스키마 자동 생성하기</h2>

<ul>
<li>DDL을 어플리케이션 실행 시점에 자동 생성</li>
<li>테이블 중심 -&gt; 객체 중심</li>
<li>데이터베이스 방언(dialect)를 활용해서 데이터베이스에 맞는 적절한 DDL 생성</li>
<li>개발 환경에서만 사용! (운영 환경에서는 다듬어서 사용)</li>
</ul>

<h3 id="4-1-옵션">4.1. 옵션</h3>

<blockquote>
<p>hibernate.hbm2ddl.auto 의 옵션(value)을 아래의 것들로 사용</p>
</blockquote>

<ul>
<li>create: 기존 테이블 삭제 후 다시 생성 (DROP + CREATE)</li>
<li>create-drop: create와 같으나 종료시점에 테이블 DROP</li>
<li>update: 변경된 부분만 반영 (운영 DB에 사용하면 안됌)</li>
<li>validate: entity와 table이 정상 매핑되었는지만 확인</li>
<li>none: 사용하지 않음</li>
</ul>

<h2 id="5-매핑-어노테이션">5. 매핑 어노테이션</h2>

<blockquote>
<p>데이터베이스에 어떤 식으로 매핑될지에 대한 매핑정보</p>
</blockquote>

<ul>
<li>@Column

<ul>
<li>@Column(name=&ldquo;EXAMPLE&rdquo;) 옵션을 주면 필드와 매핑할 DB의 컬럼명을 지정한다.</li>
<li>그 외에 insertable, updatable, nullable, unique, length 등의 옵션이 있다.</li>
</ul></li>
<li>@Temporal

<ul>
<li>날짜 타입 매핑</li>
<li>@Temporal(TemporalType.DATE) // 날짜</li>
<li>@Temporal(TemporalType.TIME) // 시간</li>
<li>@Temporal(TemporalType.TIMESTAMP) // 날짜와 시간</li>
</ul></li>
<li>@Enumerated(EnumType.STRING)

<ul>
<li>디폴트는 <code>EnumType.ORDINAL</code>인데 Enum에 정의된 순서를 숫자로 반환한다.</li>
<li>그런데 만약 순서가 바뀌면 모든게 꼬여버리므로 운영에서는 절대 사용하면 안된다.</li>
<li><code>EnumType.STRING</code> 옵션을 주면 Enum에 정의된 글자가 그대로 들어가므로, 이 옵션이 권장된다.</li>
</ul></li>
<li>@Lob

<ul>
<li>컨텐츠의 길이가 너무 길 경우에 binary파일로 DB에 넣을 경우 @Lob을 사용한다.</li>
<li>CLOB과 BLOB이 있다. CLOB은 Character 형태의 긴 컨텐츠를 저장하는 것이고, BLOB은 Binary 형태의 긴 컨텐츠를 저장하는 것이다.</li>
<li>@Lob 어노테이션을 String 타입에 쓰면 CLOB이 되고, Byte 타입에 쓰면 BLOB이 된다.</li>
</ul></li>
<li>@Transient

<ul>
<li>이 컬럼은 매핑하지 않는다.</li>
<li>컬럼을 DB에는 저장하지 않지만 객체에는 두고 싶을 때 사용 (ex 임시 flag값)</li>
</ul></li>
</ul>

<h3 id="5-1-식별자-매핑-어노테이션">5.1. 식별자 매핑 어노테이션</h3>

<ul>
<li>@Id 직접 매핑</li>
<li>@Id @GeneratedValue(strategy = GenerationType.IDENTITY)

<ul>
<li>데이터베이스에 위임 (MySQL의 AUTO INCREMENT)</li>
</ul></li>
<li>@Id @GeneratedValue(strategy = GenerationType.SEQUENCE)

<ul>
<li>데이터베이스 시퀀스 오브젝트 사용 (Oracle)</li>
<li>@SequenceGenerator 필요</li>
</ul></li>
<li>@Id @GeneratedValue(strategy = GenerationType.TABLE)

<ul>
<li>키 생성용 테이블 사용, 모든 DB에서 사용</li>
<li>@TableGenerator 필요</li>
</ul></li>
<li>@Id @GeneratedValue(strategy = GenerationType.AUTO)

<ul>
<li>디폴트</li>
<li>방언(dialect)에 따라 위의 방법 중 자동 지정</li>
</ul></li>
</ul>

<h3 id="5-2-권장하는-식별자-전략">5.2. 권장하는 식별자 전략</h3>

<ul>
<li>기본키의 제약 조건: null 아니고, 유일하며, 변하지 않는다.</li>
<li>하지만 변하지 않는 것은 없기 때문에(심지어 주민번호도) 대체키를 쓰는 것을 권장한다.</li>
<li>대체키는 데이터베이스의 Sequence, Auto Increment, 키 생성 테이블 등 비즈니스와 전혀 관계없는 것을 쓰는 것이 좋다.</li>
<li>int타입은 10억~20억 사이에서 끝나기 때문에 Long을 쓰는 것을 권장한다.</li>
<li>권장: <code>Long타입 + 대체키 + 키 생성전략</code> 사용</li>
</ul>

<h2 id="6-연관관계-매핑">6. 연관관계 매핑</h2>

<h3 id="6-1-객체를-테이블에-맞추어-모델링-할-경우">6.1. 객체를 테이블에 맞추어 모델링 할 경우</h3>

<h4 id="6-1-1-참조-대신에-외래키를-그대로-사용">6.1.1. 참조 대신에 외래키를 그대로 사용</h4>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#707a7c">@Entity</span>
<span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Member</span> {
  
  <span style="color:#707a7c">@Id</span> <span style="color:#707a7c">@GeneratedValue</span>
  <span style="color:#8b008b;font-weight:bold">private</span> Long id;
  
  <span style="color:#707a7c">@Column</span>
  <span style="color:#8b008b;font-weight:bold">private</span> String name;
  <span style="color:#8b008b;font-weight:bold">private</span> <span style="color:#00688b;font-weight:bold">int</span> age;
  
  <span style="color:#707a7c">@Column</span>(name = <span style="color:#cd5555">&#34;TEAM_ID&#34;</span>)
  <span style="color:#8b008b;font-weight:bold">private</span> Long teamID;
  ...
}

<span style="color:#707a7c">@Entity</span>
<span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Team</span> {
  
  <span style="color:#707a7c">@Id</span> <span style="color:#707a7c">@GeneratedValue</span>
  <span style="color:#8b008b;font-weight:bold">private</span> Long id;
  <span style="color:#8b008b;font-weight:bold">private</span> String name;
  ...
}</code></pre></div>
<h4 id="6-1-2-외래키-식별자를-직접-다룸">6.1.2. 외래키 식별자를 직접 다룸</h4>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#228b22">// 팀 저장
</span><span style="color:#228b22"></span>Team team = <span style="color:#8b008b;font-weight:bold">new</span> Team();
team.<span style="color:#658b00">setName</span>(<span style="color:#cd5555">&#34;TeamA&#34;</span>);
em.<span style="color:#658b00">persist</span>(team);

<span style="color:#228b22">// 회원 저장
</span><span style="color:#228b22"></span>Member member = <span style="color:#8b008b;font-weight:bold">new</span> Member();
member.<span style="color:#658b00">setName</span>(<span style="color:#cd5555">&#34;member1&#34;</span>);
member.<span style="color:#658b00">setTeamId</span>(team.<span style="color:#658b00">getId</span>()); <span style="color:#228b22">// 이 부분!
</span><span style="color:#228b22"></span>em.<span style="color:#658b00">persist</span>(member);</code></pre></div>
<h4 id="6-1-3-식별자로-다시-조회">6.1.3. 식별자로 다시 조회.</h4>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#228b22">// 조회
</span><span style="color:#228b22"></span>Member findMember = em.<span style="color:#658b00">find</span>(Member.<span style="color:#658b00">class</span>, member.<span style="color:#658b00">getId</span>());

<span style="color:#228b22">//Member와 Team이 연관관계가 없음
</span><span style="color:#228b22"></span>Team findTeam = em.<span style="color:#658b00">find</span>(Team.<span style="color:#658b00">class</span>, team.<span style="color:#658b00">getId</span>());</code></pre></div>
<p>즉, 객체를 테이블에 맞추어 모델링하는 것은 객체지향적인 방법이 아니다.<br />
객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력관계를 만들 수 없다.</p>

<ul>
<li>테이블은 외래키로 조인을 사용해서 연관된 테이블을 찾는다.</li>
<li>객체는 참조를 사용해서 연관된 객체를 찾는다.</li>
<li>이처럼 테이블과 객체는 큰 격차가 있는데, 위와 같은 방법은 이 격차를 무시한다.</li>
</ul>

<h2 id="7-단방향-매핑">7. 단방향 매핑</h2>

<h3 id="7-1-객체의-참조-team-와-테이블의-외래키-team-id-를-매핑-연관관계-매핑">7.1. 객체의 참조(team)와 테이블의 외래키(TEAM_ID)를 매핑 (=연관관계 매핑)</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#707a7c">@Entity</span>
<span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Member</span> {
  
  <span style="color:#707a7c">@Id</span> <span style="color:#707a7c">@GeneratedValue</span>
  <span style="color:#8b008b;font-weight:bold">private</span> Long id;
  
  <span style="color:#707a7c">@Column</span>
  <span style="color:#8b008b;font-weight:bold">private</span> String name;
  <span style="color:#8b008b;font-weight:bold">private</span> <span style="color:#00688b;font-weight:bold">int</span> age;
  
  <span style="color:#228b22">//@Column(name = &#34;TEAM_ID&#34;)
</span><span style="color:#228b22"></span>  <span style="color:#228b22">//private Long teamID;
</span><span style="color:#228b22"></span>  
  <span style="color:#707a7c">@ManyToOne</span>
  <span style="color:#707a7c">@JoinColumn</span>(name = <span style="color:#cd5555">&#34;TEAM_ID&#34;</span>)
  <span style="color:#8b008b;font-weight:bold">private</span> Team team;
  
  ...
}

<span style="color:#707a7c">@Entity</span>
<span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Team</span> {
  
  <span style="color:#707a7c">@Id</span> <span style="color:#707a7c">@GeneratedValue</span>
  <span style="color:#8b008b;font-weight:bold">private</span> Long id;
  <span style="color:#8b008b;font-weight:bold">private</span> String name;
  ...
}</code></pre></div>
<p>위의 코드에서 만약 <code>@ManyToOne(fetch = FetchType.LAZY)</code> 를 주면,<br />
Member 객체만 조회하고 Team 객체는 실제 사용되는 시점에 DB를 조회한다. (<code>지연 로딩</code>)<br />
그렇다고 Team 객체가 null이 되면 에러가 나기 때문에 Team 객체는 <code>프록시 객체(가짜 객체)</code>가 들어간다.<br />
디폴트는 <code>(fetch = FetchType.EAGER)</code>로 같이 조회한다.</p>

<p>권장하는 것은 <code>LAZY</code>(지연 로딩)이다.<br />
현업에서는 전부 LAZY로 바르고, 꼭 필요한 곳에서는 쿼리를 날리는 시점에 원하는 것을 미리 최적화해서 가져오는 방법을 쓰게 한다.<br />
즉, 속단해서 최적화하지 말자는 것이다.</p>

<h3 id="7-2-연관관계-저장">7.2. 연관관계 저장</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#228b22">// 팀 저장
</span><span style="color:#228b22"></span>Team team = <span style="color:#8b008b;font-weight:bold">new</span> Team();
team.<span style="color:#658b00">setName</span>(<span style="color:#cd5555">&#34;TeamA&#34;</span>);
em.<span style="color:#658b00">persist</span>(team);

<span style="color:#228b22">// 회원 저장
</span><span style="color:#228b22"></span>Member member = <span style="color:#8b008b;font-weight:bold">new</span> Member();
member.<span style="color:#658b00">setName</span>(<span style="color:#cd5555">&#34;member1&#34;</span>);
member.<span style="color:#658b00">setTeam</span>(team); <span style="color:#228b22">// 단방향 연관관계 설정, 참조 저장
</span><span style="color:#228b22"></span>em.<span style="color:#658b00">persist</span>(member);</code></pre></div>
<h3 id="7-3-참조로-연관관계-조회-객체-그래프-탐색">7.3. 참조로 연관관계 조회 - 객체 그래프 탐색</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#228b22">// 조회
</span><span style="color:#228b22"></span>Member findMember = em.<span style="color:#658b00">find</span>(Member.<span style="color:#658b00">class</span>, member.<span style="color:#658b00">getId</span>());

<span style="color:#228b22">// 참조를 사용해서 연관관계 조회
</span><span style="color:#228b22"></span>Team findTeam = findMember.<span style="color:#658b00">getTeam</span>();</code></pre></div>
<h2 id="8-양방향-매핑">8. 양방향 매핑</h2>

<h3 id="8-1-team-객체에서도-member-갖도록">8.1. Team 객체에서도 Member 갖도록</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#707a7c">@Entity</span>
<span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Team</span> {
  
  <span style="color:#707a7c">@Id</span> <span style="color:#707a7c">@GeneratedValue</span>
  <span style="color:#8b008b;font-weight:bold">private</span> Long id;
  <span style="color:#8b008b;font-weight:bold">private</span> String name;
  
  <span style="color:#707a7c">@OneToMany</span>(mappedBy = <span style="color:#cd5555">&#34;team&#34;</span>)
  List&lt;Member&gt; members = <span style="color:#8b008b;font-weight:bold">new</span> ArrayList&lt;Member&gt;();
  ...
}</code></pre></div>
<h3 id="8-2-반대-방향으로-객체-그래프-탐색">8.2. 반대 방향으로 객체 그래프 탐색</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#228b22">// 조회
</span><span style="color:#228b22"></span>Team findTeam = em.<span style="color:#658b00">find</span>(Team.<span style="color:#658b00">class</span>, team.<span style="color:#658b00">getId</span>());

<span style="color:#228b22">// 역방향 조회
</span><span style="color:#228b22"></span><span style="color:#00688b;font-weight:bold">int</span> memberSize = findTeam.<span style="color:#658b00">getMembers</span>().<span style="color:#658b00">size</span>();</code></pre></div>
<h3 id="8-3-객체와-테이블이-관계를-맺는-차이">8.3. 객체와 테이블이 관계를 맺는 차이</h3>

<ul>
<li>객체 연관관계

<ul>
<li>회원 -&gt; 팀 연관관계 1개 (단방향)</li>
<li>팀 -&gt; 회원 연관관계 1개 (단방향)</li>
</ul></li>
<li>테이블 연관관계

<ul>
<li>회원 &lt;-&gt; 팀 연관관계 1개 (양방향)</li>
</ul></li>
</ul>

<h3 id="8-4-객체의-양방향-관계">8.4. 객체의 양방향 관계</h3>

<ul>
<li>객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개이다.</li>
<li>객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.</li>
</ul>

<h3 id="8-5-테이블의-양방향-관계">8.5. 테이블의 양방향 관계</h3>

<ul>
<li>테이블은 외래키 하나로 두 테이블의 연관관계 관리</li>
<li>MEMBER.TEAM_ID 외래키 하나로 양방향 연관관계를 가짐 (양쪽으로 조인할 수 있다.)</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#8b008b;font-weight:bold">SELECT</span> *
<span style="color:#8b008b;font-weight:bold">FROM</span> MEMBER M
<span style="color:#8b008b;font-weight:bold">JOIN</span> TEAM T <span style="color:#8b008b;font-weight:bold">ON</span> M.TEAM_ID = T.TEAM_ID

<span style="color:#8b008b;font-weight:bold">SELECT</span> *
<span style="color:#8b008b;font-weight:bold">FROM</span> TEAM T
<span style="color:#8b008b;font-weight:bold">JOIN</span> MEMBER M <span style="color:#8b008b;font-weight:bold">ON</span> T.TEAM_ID = M.TEAM_ID</code></pre></div>
<h3 id="8-6-객체의-양방향-관계에서의-문제점">8.6. 객체의 양방향 관계에서의 문제점</h3>

<p>예를 들어 Member 객체에서 Team 객체의 값을 변경시키거나,<br />
Team 객체에서 members에 member를 추가하는 등의 변화가 양쪽에서 일어난다면 어느쪽을 신뢰해야 하는가?</p>

<p>그래서 둘 중 하나로 외래키를 관리해야 한다.<br />
즉, 한 쪽을 <code>연관관계의 주인</code>으로 만들어주고 나머지 한쪽을 조회만 하도록 하는 것이다.</p>

<h3 id="8-7-양방향-매핑-규칙">8.7. 양방향 매핑 규칙</h3>

<ul>
<li>객체의 두 관계 중 하나를 연관관계의 주인으로 지정</li>
<li>연관관계의 주인만이 외래키를 관리 (등록, 수정)</li>
<li>주인이 아닌 쪽은 읽기만 가능</li>
<li>주인은 mappedBy 속성 사용 X</li>
<li>주인이 아니면 mappedBy 속성으로 주인 지정</li>
</ul>

<h3 id="8-8-누구를-주인으로">8.8. 누구를 주인으로?</h3>

<ul>
<li>외래키가 있는 곳을 주인으로 정해라</li>
<li>권장하는 것은 단방향으로 설계를 끝내고 개발하면서 양방향이 필요한 부분이 생기면 코드를 추가하는 방식을 권한다.</li>
</ul>

<h3 id="8-9-양방향-매핑시-가장-많이하는-실수">8.9. 양방향 매핑시 가장 많이하는 실수</h3>

<ul>
<li>연관관계의 주인에 값을 입력하지 않는 것.</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Team team = <span style="color:#8b008b;font-weight:bold">new</span> Team();
team.<span style="color:#658b00">setName</span>(<span style="color:#cd5555">&#34;TeamA&#34;</span>);
em.<span style="color:#658b00">persist</span>(team);

Member member = <span style="color:#8b008b;font-weight:bold">new</span> Member();
member.<span style="color:#658b00">setName</span>(<span style="color:#cd5555">&#34;member1&#34;</span>);

<span style="color:#228b22">//역방향(주인이 아닌 방향)만 연관관계 설정
</span><span style="color:#228b22"></span>team.<span style="color:#658b00">getMembers</span>().<span style="color:#658b00">add</span>(member);
em.<span style="color:#658b00">persist</span>(member);</code></pre></div>
<p>이 경우, TEAM_ID가 null이 된다.</p>

<p>현업에서는 그냥 양쪽 모두 값을 입력하면 된다.<br />
객체지향 관점에서도 양쪽 모두 값을 입력하는 것이 맞다.</p>

<h3 id="8-10-양방향-매핑의-장점">8.10. 양방향 매핑의 장점</h3>

<ul>
<li>단방향 매핑만으로도 이미 연관관계 매핑은 완료</li>
<li>양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐</li>
<li>JPQL에서 역방향으로 탐색할 일이 많음</li>
<li>단방향 매핑을 잘하고 양방향 매핑은 필요할 때 추가하면 됌. (테이블에 영향 없음)</li>
</ul>

<h2 id="9-jpa-내부-구조-영속성-컨텍스트">9. JPA 내부 구조 - 영속성 컨텍스트</h2>

<p>JPA에서 가장 중요한 2가지</p>

<ul>
<li>객체와 관계형 데이터베이스 매핑하기</li>
<li>영속성 컨텍스트(PersistenceContext)</li>
</ul>

<h3 id="9-1-영속성-컨텍스트-란">9.1. 영속성 컨텍스트 란?</h3>

<ul>
<li>JPA를 이해하는데 가장 중요한 용어</li>
<li><code>엔티티를 영구 저장하는 환경</code>이라는 뜻</li>
<li>영속성 컨텍스트는 논리적인 개념(눈에 보이지 않는다.)</li>
<li>엔티티 매니저를 통해서 영속성 컨텍스트에 접근</li>
<li>엔티티 매니저와 영속성 컨텍스트는 1:1 이라서 그냥 <code>EntityManager = PersistenceContext</code>라고 이해하면 된다.

<ul>
<li>스프링 프레임워크 같은 컨테이너 환경에서는 EntityManager와 PersistenceContext가 <code>N:1</code>이다.</li>
</ul></li>
<li>같은 트랜잭션이면 같은 영속성 컨텍스트에 접근하게 된다.<br /></li>
</ul>

<h3 id="9-2-entity의-생명주기">9.2. Entity의 생명주기</h3>

<ul>
<li>비영속(new/transient)

<ul>
<li>영속성 컨텍스트와 전혀 관계가 없는 상태</li>
<li>Member 객체를 생성만 한 상태</li>
</ul></li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  <span style="color:#228b22">//객체를 생성한 상태(비영속)
</span><span style="color:#228b22"></span>  Member member = <span style="color:#8b008b;font-weight:bold">new</span> Member();
  member.<span style="color:#658b00">setId</span>(<span style="color:#cd5555">&#34;memberId&#34;</span>);
  member.<span style="color:#658b00">setUsername</span>(<span style="color:#cd5555">&#34;회원1&#34;</span>);</code></pre></div>
<ul>
<li>영속(managed)

<ul>
<li>영속성 컨텍스트에 저장된 상태</li>
<li>객체를 생성하고 저장한 상태(영속성 컨텍스트에 의해서 객체가 관리(managed)되는 상태)</li>
</ul></li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  Member member = <span style="color:#8b008b;font-weight:bold">new</span> Member();
  member.<span style="color:#658b00">setId</span>(<span style="color:#cd5555">&#34;memberId&#34;</span>);
  member.<span style="color:#658b00">setUsername</span>(<span style="color:#cd5555">&#34;회원1&#34;</span>);
  
  EntityManager em = emf.<span style="color:#658b00">createEntityManager</span>();
  em.<span style="color:#658b00">getTransaction</span>().<span style="color:#658b00">begin</span>();
  
  <span style="color:#228b22">//객체를 저장한 상태(영속)
</span><span style="color:#228b22"></span>  em.<span style="color:#658b00">persist</span>(member);</code></pre></div>
<ul>
<li>준영속(detached)

<ul>
<li>영속성 컨텍스트에 저장되었다가 분리된 상태</li>
<li><code>em.detach(member);</code></li>
</ul></li>
<li>삭제(removed)

<ul>
<li>삭제된 상태</li>
<li><code>em.remove(member);</code></li>
</ul></li>
</ul>

<h2 id="10-영속성-컨텍스트의-이점">10. 영속성 컨텍스트의 이점</h2>

<h3 id="10-1-1차-캐시">10.1. 1차 캐시</h3>

<ul>
<li>PersistenceContext에는 내부에 1차 캐시가 있다. 일반적인 캐시가 아니라 영속성컨텍스가 생성되고 없어질 때 까지만 잠깐 존재하는 것.</li>
<li>1차 캐시에서 조회</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Member member = <span style="color:#8b008b;font-weight:bold">new</span> Member();
member.<span style="color:#658b00">setId</span>(<span style="color:#cd5555">&#34;member1&#34;</span>);
member.<span style="color:#658b00">setUsername</span>(<span style="color:#cd5555">&#34;회원1&#34;</span>);

<span style="color:#228b22">//1차 캐시에 저장됌
</span><span style="color:#228b22"></span>em.<span style="color:#658b00">persist</span>(member);

<span style="color:#228b22">//1차 캐시에서 조회
</span><span style="color:#228b22"></span>Member findMember = em.<span style="color:#658b00">find</span>(Member.<span style="color:#658b00">class</span>, <span style="color:#cd5555">&#34;member1&#34;</span>);</code></pre></div>
<p><code>em.find()</code>에서 DB로 바로가는 것이 아니라 1차 캐시를 먼저 탐색한다. (존재하면 바로 반환)</p>

<ul>
<li>1차 캐시에 없으면

<ul>
<li>데이터베이스에서 조회하고</li>
<li>조회된 내용을 1차 캐시에 저장 후에 반환
<br /></li>
</ul></li>
</ul>

<h3 id="10-2-영속-엔티티의-동일성-identity-보장">10.2. 영속 엔티티의 동일성(identity) 보장</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Member a = em.<span style="color:#658b00">find</span>(Member.<span style="color:#658b00">class</span>, <span style="color:#cd5555">&#34;member1&#34;</span>);
Member b = em.<span style="color:#658b00">find</span>(Member.<span style="color:#658b00">class</span>, <span style="color:#cd5555">&#34;member2&#34;</span>);

System.<span style="color:#658b00">out</span>.<span style="color:#658b00">println</span>(a == b); // 동일성 비교 <span style="color:#8b008b;font-weight:bold">true</span> -&gt; 위에서 보았듯이 1차캐시가 있기 때문에</code></pre></div>
<ul>
<li>1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 어플리케이션 차원에서 제공
<br /></li>
</ul>

<h3 id="10-3-트랜잭션을-지원하는-쓰기-지연-transactional-write-behind-버퍼-기능">10.3. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) - 버퍼 기능</h3>

<ul>
<li>예를 들어 <code>persist(memberA)</code> 명령의 경우 memberA를 1차 캐시에 저장하면서 동시에 INSERT SQL을 생성해서 <code>쓰기 지연 SQL 저장소</code>에 말아놓는다.</li>
<li>이후에 <code>persist(memberB)</code> 명령의 경우도 위와 같이 동작하고, 여전히 DB에 넣지 않는다.</li>
<li>이후에 <code>commit()</code> 명령을 해야 쓰기 지연 SQL 저장소에 있던 INSERT SQL 쿼리 2개를 (옵션에 따라 동시에 혹은 하나씩) DB에 넣는다.</li>
<li><code>쓰기 지연 SQL 저장소</code>에 있던 쿼리들을 날리는 과정을 <code>flush</code>라고 한다.

<ul>
<li>하지만 flush를 한다고 1차캐시의 내용들이 지워지는 것이 아니라 쿼리를 보내서 DB와 싱크를 맞추는 역할을 한다.</li>
<li><code>commit()</code> 이 flush와 commit 두 가지 일을 하는 것이다.</li>
</ul></li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">EntityManager em = emf.<span style="color:#658b00">createEntityManager</span>();
EntityTransaction transaction = em.<span style="color:#658b00">getTransaction</span>();
<span style="color:#228b22">// 엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.
</span><span style="color:#228b22"></span>transaction.<span style="color:#658b00">begin</span>();

em.<span style="color:#658b00">persist</span>(memberA);
em.<span style="color:#658b00">persist</span>(memberB);
<span style="color:#228b22">//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.
</span><span style="color:#228b22"></span>
<span style="color:#228b22">//커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
</span><span style="color:#228b22"></span>transaction.<span style="color:#658b00">commit</span>(); // [트랜잭션] 커밋</code></pre></div>
<h3 id="10-4-변경-감지-dirty-checking">10.4. 변경 감지(Dirty Checking)</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">EntityManager em = emf.<span style="color:#658b00">createEntityManager</span>();
EntityTransaction transaction = em.<span style="color:#658b00">getTransaction</span>();
<span style="color:#228b22">// 엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.
</span><span style="color:#228b22"></span>transaction.<span style="color:#658b00">begin</span>(); <span style="color:#228b22">// [트랜잭션] 시작
</span><span style="color:#228b22"></span>
<span style="color:#228b22">// 영속 엔티티 조회
</span><span style="color:#228b22"></span>Member memberA = em.<span style="color:#658b00">find</span>(Member.<span style="color:#658b00">class</span>, <span style="color:#cd5555">&#34;memberA&#34;</span>);

<span style="color:#228b22">// 영속 엔티티 데이터 수정
</span><span style="color:#228b22"></span>memberA.<span style="color:#658b00">setName</span>(<span style="color:#cd5555">&#34;hjs&#34;</span>);
memberA.<span style="color:#658b00">setAge</span>(10);

<span style="color:#228b22">// 수정했으니 em.update(member) 이런 코드가 있어야 하지 않을까?
</span><span style="color:#228b22"></span>
<span style="color:#228b22">// 하지만 필요없다. 커밋하면 자동으로 업데이트 쿼리가 나간다.
</span><span style="color:#228b22"></span>transaction.<span style="color:#658b00">commit</span>(); // [트랜잭션] 커밋</code></pre></div>
<ul>
<li>Dirty Checking의 동작 원리

<ul>
<li>JPA는 트랜잭션이 커밋되는 시점에 1차 캐시 뿐만 아니라 스냅샷도 생성한다.</li>
<li>commit()명령으로 flush를 하면 영속성 컨텍스트에 의해 관리되는 엔티티들을 스냅샷과 비교해서 바뀐 부분이 있으면 UPDATE 쿼리를 만들어서 DB에 보내고 commit을 한다.</li>
</ul></li>
<li>이렇게 하는 이유

<ul>
<li>Java 컬렉션에서 값을 가져와서 변경해도 다시 컬렉션에 값을 담지 않는다. 그래도 컬렉션의 값이 바뀐다. 그것과 똑같은 컨셉이다.</li>
<li>마치 Java 컬렉션에서 값을 가져와서 변경하는 것 처럼하기 위해 이런 방식으로 처리한다.
<br /></li>
</ul></li>
</ul>

<h3 id="10-5-지연-로딩-lazy-loading">10.5. 지연 로딩(Lazy Loading)</h3>

<h2 id="11-flush">11. Flush</h2>

<h3 id="11-1-영속성-컨텍스트를-flush-하는-방법">11.1. 영속성 컨텍스트를 flush 하는 방법</h3>

<ul>
<li>em.flush() - 직접 호출</li>
<li>트랜잭션 커밋 - 플러시 자동 호출</li>

<li><p>JPQL 쿼리 실행 - 플러시 자동 호출</p>

<ul>
<li>JPQL 쿼리 실행시 flush가 자동으로 호출되는 이유</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">em.<span style="color:#658b00">persist</span>(memberA);
em.<span style="color:#658b00">persist</span>(memberB);
em.<span style="color:#658b00">persist</span>(memberC);
    
<span style="color:#228b22">// 중간에 JPQL 실행  
</span><span style="color:#228b22"></span>query = em.<span style="color:#658b00">createQuery</span>(<span style="color:#cd5555">&#34;select m from Member m&#34;</span>, Member.<span style="color:#658b00">class</span>);
List&lt;Member&gt; members = query.<span style="color:#658b00">getResultList</span>();</code></pre></div>
<ul>
<li>이 상황에서는 DB에서 데이터 조회가 하나도 안된다. flush가 안되었기 때문에.</li>
<li>때문에 JPA에서는 JPQL을 실행하면 flush가 자동으로 호출되도록 했다. (MyBatis나 Spring JDBC와 함께 사용할 때는 flush를 직접 해줘야 한다.)</li>
</ul></li>
</ul>

<h3 id="11-2-flush-옵션">11.2. Flush 옵션</h3>

<ul>
<li><code>em.setFlushMode(FlushModeType.AUTO)</code> - 디폴트

<ul>
<li>커밋이나 쿼리를 실행할 때 flush</li>
</ul></li>
<li><code>em.setFlushMode(FlushModeType.COMMIT)</code>

<ul>
<li>커밋할 때만 flush
<br /></li>
</ul></li>
</ul>

<h3 id="11-3-flush는">11.3. Flush는!</h3>

<ul>
<li>영속성 컨텍스트를 비우지 않음</li>
<li>영속성 컨텍스트의 변경내용을 데이터베이스에 동기화하는 것이 flush의 목적</li>
<li>flush가 가능한 이유는 DB에 트랜잭션이라는 작업 단위가 있기 때문. -&gt; 커밋 직전에만 동기화하면 됨</li>
</ul>

<h2 id="12-준영속-상태">12. 준영속 상태</h2>

<ul>
<li>영속 상태의 Entity가 영속성 컨텍스트에서 분리(detached)</li>
<li>영속성 컨텍스트가 제공하는 기능을 사용 못함</li>
</ul>

<h3 id="12-1-준영속-상태로-만드는-방법">12.1. 준영속 상태로 만드는 방법</h3>

<ul>
<li>em.detach(entity)

<ul>
<li>특정 엔티티만 준영속 상태로 전환</li>
</ul></li>
<li>em.clear()

<ul>
<li>영속성 컨텍스트를 완전히 초기화</li>
</ul></li>
<li>em.close()

<ul>
<li>영속성 컨텍스트를 종료</li>
</ul></li>
</ul>

<h3 id="12-2-준영속-상태면-지연-로딩을-못쓴다">12.2. 준영속 상태면 지연 로딩을 못쓴다.</h3>

<p>지연 로딩을 쓰려면 영속성 컨텍스트가 살아있어야 한다.<br />
영속성 컨텍스트가 죽어있는데 지연 로딩이 적용된 객체를 터치하면 <code>LazyInitializationException</code> 에러가 터진다.(현업에서 자주 만난다.)<br />
영속성 컨텍스트가 DB커넥션 등을 다 들고있기 때문에 그렇다.</p>

<h3 id="12-3-프록시와-즉시로딩-eager-주의">12.3. 프록시와 즉시로딩(EAGER) 주의</h3>

<ul>
<li>가급적 지연 로딩(LAZY)을 사용</li>
<li>즉시 로딩을 적용하면 예상하지 못한 SQL이 발생</li>
<li>즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.</li>
<li>@ManyToOne, @OneToOne은 기본이 즉시 로딩 -&gt; LAZY로 설정할 것.</li>
<li>@OneToMany, @ManyToMany는 기본이 지연 로딩</li>
</ul>

<h2 id="13-jpql">13. JPQL</h2>

<ul>
<li>JPA를 사용하면 Entity 객체 중심으로 개발</li>
<li>문제는 검색 쿼리</li>
<li>검색을 할 때도 테이블이 아닌 Entity 객체를 대상으로 검색</li>
<li>모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능</li>
<li>어플리케이션이 필요한 데이터만 DB에서 불러내려면, 결국 검색 조건이 포함된 SQL이 필요</li>
</ul>

<p>그래서 JPA는 SQL을 추상화한 JPQL이라는 객체지향 쿼리 언어 제공.<br />
SQL과 문법 유사(SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN).<br />
JPQL은 Entity 객체를 대상으로 쿼리. (SQL은 데이터베이스 테이블을 대상으로 쿼리)</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#228b22">// 검색
</span><span style="color:#228b22"></span>String jpql = <span style="color:#cd5555">&#34;select m From Member m where m.name like &#39;%hello%&#39;&#34;</span>; <span style="color:#228b22">//Member는 객체.
</span><span style="color:#228b22"></span>
List&lt;Member&gt; result = em.<span style="color:#658b00">createQuery</span>(jpql, Member.<span style="color:#658b00">class</span>).<span style="color:#658b00">getResultList</span>();</code></pre></div>
<p>JPQL은 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리.<br />
SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.<br />
JPQL을 한마디로 정의하면 객체 지향 SQL</p>

<h3 id="13-1-jpql-문법">13.1. JPQL 문법</h3>

<ul>
<li>Entity와 속성은 대소문자 구분</li>
<li>JPQL 키워드는 대소문자 구분 안함(SELECT, FROM, where)</li>
<li>Entity 이름을 사용, 테이블 이름이 아님</li>
<li>별칭은 필수</li>
<li>결과 조회 API

<ul>
<li><code>query.getResultList()</code> : 결과가 하나 이상, 리스트 반환</li>
<li><code>query.getSingleResult()</code> : 결과가 정확히 하나, 단일 객체 반환(정확히 하나가 아니면 예외 발생)</li>
</ul></li>
<li>파라미터 바인딩</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  SELECT m FROM Member m where m.<span style="color:#658b00">username</span>=:username
  query.<span style="color:#658b00">setParameter</span>(<span style="color:#cd5555">&#34;username&#34;</span>, usernameParam); <span style="color:#228b22">//이름 기준 (권장)
</span><span style="color:#228b22"></span>  
  SELECT m FROM Member m where m.<span style="color:#658b00">username</span>=?1
  query.<span style="color:#658b00">setParameter</span>(1, usernameParam); //위치 기준</code></pre></div>
<ul>
<li>프로젝션

<ul>
<li><code>SELECT m FROM Member m</code> -&gt; 엔티티 프로젝션</li>
<li><code>SELECT m.team FROM Member m</code> -&gt; 엔티티 프로젝션</li>
<li><code>SELECT username, age FROM Member m</code> -&gt; 단순 값 프로젝션</li>
<li>new 명령어: 단순 값을 DTO로 바로 조회</li>
<li><code>SELECT new jpabook.jpql.UserDTO(m.username,m.age) FROM Member m</code></li>
<li>DISTINCT는 중복 제거</li>
</ul></li>

<li><p>페이징 API</p>

<ul>
<li>JPA는 페이징을 다음 두 API로 추상화</li>
<li>setFirstResult(int startPosition): 조회 시작 위치(0부터 시작)</li>
<li>setMaxResults(int maxResult): 조회할 데이터 수</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#228b22">//페이징 쿼리
</span><span style="color:#228b22"></span>String jpql = <span style="color:#cd5555">&#34;select m from Member m order by m.name desc&#34;</span>;
List&lt;Member&gt; resultList = em.<span style="color:#658b00">createQuery</span>(jpql, Member.<span style="color:#658b00">class</span>)
        .<span style="color:#658b00">setFirstResult</span>(10)
        .<span style="color:#658b00">setMaxResults</span>(20)
        .<span style="color:#658b00">getResultList</span>();</code></pre></div></li>

<li><p>집합과 정렬</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#8b008b;font-weight:bold">select</span>
<span style="color:#8b008b;font-weight:bold">COUNT</span>(m), //<span style="color:#a61717;background-color:#e3d2d2">회원수</span>
<span style="color:#8b008b;font-weight:bold">SUM</span>(m.age), //<span style="color:#a61717;background-color:#e3d2d2">나이</span> <span style="color:#a61717;background-color:#e3d2d2">합</span>
<span style="color:#8b008b;font-weight:bold">AVG</span>(m.age), //<span style="color:#a61717;background-color:#e3d2d2">평균</span> <span style="color:#a61717;background-color:#e3d2d2">나이</span>
<span style="color:#8b008b;font-weight:bold">MAX</span>(m.age), //<span style="color:#a61717;background-color:#e3d2d2">최대</span> <span style="color:#a61717;background-color:#e3d2d2">나이</span>
<span style="color:#8b008b;font-weight:bold">MIN</span>(m.age)  //<span style="color:#a61717;background-color:#e3d2d2">최소</span> <span style="color:#a61717;background-color:#e3d2d2">나이</span>
<span style="color:#8b008b;font-weight:bold">from</span> Member m</code></pre></div></li>

<li><p>조인 (일반 조인과 문법이 약간 다름)</p>

<ul>
<li>내부 조인</li>
<li><code>SELECT m FROM Member m [INNER] JOIN m.team t</code></li>
<li>외부 조인</li>
<li><code>SELECT m FROM Member m LEFT [OUTER] JOIN m.team t</code></li>
<li>세타 조인 (= 막 조인. 연관관계 상관 없이 조인)</li>
<li><code>select count(m) from Member m, Team t where m.username = t.name</code></li>
<li>하이버네이트 5.1부터 세타 조인도 외부 조인 가능</li>
<li>fetch 조인</li>
<li>Entity 객체 그래프를 한번에 조회하는 방법</li>
<li>별칭을 사용할 수 없다.</li>
<li>JPQL: <code>select m from Member m join fetch m.team</code> - <strong>Member를 조회할 때 Team까지 같이 가지고 오는 것.</strong></li>
<li>SQL: <code>SELECT M.*, T.* FROM MEMBER T INNER JOIN TEAM T ON M.TEAM_ID=T.ID</code></li>
<li>fetch 조인 예시</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String jpql = <span style="color:#cd5555">&#34;select m from Member m join fetch m.team&#34;</span>;

List&lt;Member&gt; members = em.<span style="color:#658b00">createQuery</span>(jpql, Member.<span style="color:#658b00">class</span>).<span style="color:#658b00">getResultList</span>();

<span style="color:#8b008b;font-weight:bold">for</span> (Member member : members) {
    <span style="color:#228b22">// fetch 조인으로 Member와 Team을 함께 조회해서 지연 로딩 발생 안함
</span><span style="color:#228b22"></span>    System.<span style="color:#658b00">out</span>.<span style="color:#658b00">println</span>(<span style="color:#cd5555">&#34;username = &#34;</span> + member.<span style="color:#658b00">getUsername</span>() + <span style="color:#cd5555">&#34;, &#34;</span> + <span style="color:#cd5555">&#34;teamname = &#34;</span> + member.<span style="color:#658b00">getTeam</span>().<span style="color:#658b00">name</span>());</code></pre></div></li>

<li><p>사용자 정의 함수 호출</p>

<ul>
<li><code>select function('group_concat', i.name) from Item i</code></li>
<li>하이버네이트는 사용 전 방언에 추가해야 한다.</li>
</ul></li>

<li><p>Named 쿼리</p>

<ul>
<li>미리 정의해서 이름을 부여해두고 사용하는 JPQL</li>
<li>어노테이션, XML에 정의</li>
<li>어플리케이션 로딩 시점에 초기화 후 재사용</li>
<li><strong>어플리케이션 로딩 시점에 쿼리를 검증</strong>
<br /></li>
</ul></li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  <span style="color:#707a7c">@Entity</span>
  <span style="color:#707a7c">@NamedQuery</span>(
          name = <span style="color:#cd5555">&#34;Member.findByUsername&#34;</span>,
          query = <span style="color:#cd5555">&#34;select m from Member m where m.username = :username&#34;</span>)
  <span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Member</span> {
      ...
  }</code></pre></div><div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  List&lt;Member&gt; resultList =
    em.<span style="color:#658b00">createNamedQuery</span>(<span style="color:#cd5555">&#34;Member.findByUsername&#34;</span>, Member.<span style="color:#658b00">class</span>)
          .<span style="color:#658b00">setParameter</span>(<span style="color:#cd5555">&#34;username&#34;</span>, <span style="color:#cd5555">&#34;회원1&#34;</span>)
          .<span style="color:#658b00">getResultList</span>();</code></pre></div>
<h2 id="14-spring-data-jpa">14. Spring Data JPA</h2>

<h3 id="14-1-spring-data-jpa-적용-전">14.1. Spring Data JPA 적용 전</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">MemberRepository</span> {
  
  <span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">save</span>(Member member) {...}
  <span style="color:#8b008b;font-weight:bold">public</span> Member <span style="color:#008b45">findOne</span>(Long id) {...}
  <span style="color:#8b008b;font-weight:bold">public</span> List&lt;Member&gt; <span style="color:#008b45">findAll</span>() {...} <span style="color:#228b22">// 공통
</span><span style="color:#228b22"></span>  
  <span style="color:#8b008b;font-weight:bold">public</span> Member <span style="color:#008b45">findByName</span>(String name) {...} <span style="color:#228b22">// 공통 아님
</span><span style="color:#228b22"></span>}

<span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">ItemRepository</span> {

  <span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">save</span>(Member member) {...}
  <span style="color:#8b008b;font-weight:bold">public</span> Member <span style="color:#008b45">findOne</span>(Long id) {...}
  <span style="color:#8b008b;font-weight:bold">public</span> List&lt;Member&gt; <span style="color:#008b45">findAll</span>() {...}
}</code></pre></div>
<p>위와 같이 결국 CRUD가 반복된다.<br />
Spring Data JPA는 지루하게 반복되는 CRUD 문제를 <strong>세련된 방법</strong>으로 해결.<br />
개발자는 인터페이스만 작성하고, 스프링 데이터 JPA가 구현 객체를 동적으로 생성해서 주입.</p>

<h3 id="14-2-spring-data-jpa-적용-후">14.2. Spring Data JPA 적용 후</h3>

<p>Spring Data JPA가 로딩 시점에 ItemRepository를 확인하고 구현클래스를 생성해준다.</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">interface</span> <span style="color:#008b45;font-weight:bold">MemberRepository</span> <span style="color:#8b008b;font-weight:bold">extends</span> JpaRepository&lt;Member, Long&gt; {
    Member <span style="color:#008b45">findByName</span>(String name);
}

<span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">interface</span> <span style="color:#008b45;font-weight:bold">ItemRepository</span> <span style="color:#8b008b;font-weight:bold">extends</span> JpaRepository&lt;Item, Long&gt; {
    <span style="color:#228b22">// 비어있음
</span><span style="color:#228b22"></span>}</code></pre></div>
<p>공통화 할 수 없었던 <code>Member findByName(String name);</code> 을 제외하고는 JpaRepository 인터페이스를 상속받으면 끝이다.<br />
즉, JpsRepository 인터페이스는 공통 CRUD를 제공해준다.<br />
제네릭은 <code>&lt;엔티티, 식별자&gt;</code>로 설정.</p>

<p>Spring Data JPA는 Spring Data 프로젝트의 인터페이스를 상속 받은 것이다.<br />
스프링 데이터 JPA의 <code>JpaRepository</code> 인터페이스 -&gt;<br />
스프링 데이터의 <code>PagingAndSortingRepository</code> 인터페이스 -&gt;<br />
<code>CrudRepository</code> 인터페이스 -&gt;<br />
<code>Repository</code> 인터페이스</p>

<h3 id="14-3-쿼리-메서드-기능">14.3. 쿼리 메서드 기능</h3>

<ul>
<li><p>메서드 이름만으로 JPQL 쿼리 생성</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">interface</span> <span style="color:#008b45;font-weight:bold">MemberRepository</span> <span style="color:#8b008b;font-weight:bold">extends</span> JpaRepository&lt;Member, Long&gt; {
List&lt;Member&gt; <span style="color:#008b45">findByName</span>(String name); <span style="color:#228b22">//이렇게만 작성하면 알아서 JPQL 짜줌
</span><span style="color:#228b22"></span>}</code></pre></div>
<ul>
<li>예를 들어 <code>List&lt;Member&gt; member = memberRepository.findByName(&quot;hello&quot;)</code>의 경우 실행될 SQL은</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#8b008b;font-weight:bold">SELECT</span>*<span style="color:#8b008b;font-weight:bold">FROM</span> MEMBER M <span style="color:#8b008b;font-weight:bold">WHERE</span> M.NAME = <span style="color:#cd5555">&#39;hello&#39;</span></code></pre></div>
<ul>
<li>이름으로 검색+정렬 하는 경우</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">pulbic <span style="color:#8b008b;font-weight:bold">interface</span> <span style="color:#008b45;font-weight:bold">MemberRepository</span> <span style="color:#8b008b;font-weight:bold">extends</span> JpaRepository&lt;Member, Long&gt; {
    List&lt;Member&gt; <span style="color:#008b45">findByName</span>(String name, Sort sort); <span style="color:#228b22">// Sort가 이미 구현되어 있다.
</span><span style="color:#228b22"></span>}</code></pre></div><div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#8b008b;font-weight:bold">SELECT</span> * <span style="color:#8b008b;font-weight:bold">FROM</span> MEMBER M <span style="color:#8b008b;font-weight:bold">WHERE</span> M.NAME = <span style="color:#cd5555">&#39;hello&#39;</span> <span style="color:#8b008b;font-weight:bold">ORDER</span> <span style="color:#8b008b;font-weight:bold">BY</span> AGE <span style="color:#8b008b;font-weight:bold">DESC</span></code></pre></div>
<ul>
<li>이름으로 검색+정렬+페이징 하는 경우</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">interface</span> <span style="color:#008b45;font-weight:bold">MemberRepository</span> <span style="color:#8b008b;font-weight:bold">extends</span> JpaRepository&lt;Member, Long&gt; {
    Page&lt;Member&gt; <span style="color:#008b45">findByName</span>(String name, Pageable pageable);
}</code></pre></div>
<p>예를 들어 아래와 같이 작성하면 된다.</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#707a7c">@RequestMapping</span>(<span style="color:#cd5555">&#34;/search&#34;</span>)
Page&lt;Member&gt; <span style="color:#008b45">search</span>(<span style="color:#707a7c">@RequestParam</span>(<span style="color:#cd5555">&#34;name&#34;</span>) String name, Pageable pageable) {
  PageRequest pageRequest = PageRequest.<span style="color:#658b00">of</span>(1, 10); <span style="color:#228b22">// 페이지 번호, 사이즈
</span><span style="color:#228b22"></span>  <span style="color:#8b008b;font-weight:bold">return</span> repository.<span style="color:#658b00">findByName</span>(name, pageRequest);
}</code></pre></div></li>

<li><p>@Query 어노테이션으로 쿼리 직접 정의</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">interface</span> <span style="color:#008b45;font-weight:bold">MemberRepository</span> <span style="color:#8b008b;font-weight:bold">extends</span> JpaRepository&lt;Member, Long&gt; {
  
<span style="color:#707a7c">@Query</span>(<span style="color:#cd5555">&#34;select m from Member m where m.name = ?1&#34;</span>)
Member <span style="color:#008b45">findByName</span>(String name, Pageable pageable);
}</code></pre></div></li>
</ul>

<h3 id="14-4-반환-타입-지정">14.4. 반환 타입 지정</h3>

<p>반환 타입을 정할 수 있다.</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">List&lt;Member&gt; <span style="color:#008b45">findByName</span>(String name); <span style="color:#228b22">// 컬렉션
</span><span style="color:#228b22"></span>Member <span style="color:#008b45">findByEmail</span>(String email); // 단건</code></pre></div>
<h3 id="14-5-web-페이징과-정렬-기능">14.5. Web 페이징과 정렬 기능</h3>

<p>컨트롤러에서 페이징 처리 객체를 바로 받을 수 있다.<br />
<code>/members?page=0&amp;size=20&amp;sort=name,desc</code></p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#707a7c">@RequestMapping</span>(vlaue = <span style="color:#cd5555">&#34;/members&#34;</span>, method = RequestMethod.<span style="color:#658b00">GET</span>)
String <span style="color:#008b45">list</span>(Pageable pageable, Model model) {...}</code></pre></div>
<h3 id="14-6-web-도메인-클래스-컨버터-기능">14.6. Web 도메인 클래스 컨버터 기능</h3>

<p>컨트롤러에서 식별자로 도메인 클래스 찾음<br />
<code>/members/100</code></p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#707a7c">@RequestMapping</span>(<span style="color:#cd5555">&#34;/members/{memberId}&#34;</span>)
Member <span style="color:#008b45">member</span>(<span style="color:#707a7c">@PathVariable</span>(<span style="color:#cd5555">&#34;memberId&#34;</span>) Member member) {
    <span style="color:#8b008b;font-weight:bold">return</span> member;
}</code></pre></div>
<h2 id="15-querydsl">15. QueryDSL</h2>

<ul>
<li>SQL과 JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API</li>
<li>JPA criteria에 비해서 편리하고 실용적이다.</li>
<li>오픈소스</li>
</ul>

<h3 id="15-1-sql-jpql의-문제점">15.1. SQL, JPQL의 문제점</h3>

<ul>
<li>SQL, JPQL은 문자, Type-check 불가능</li>
<li>해당 로직 실행 전까지 작동여부 확인 불가(컴파일 시점에 알 수 없다.)</li>
</ul>

<h3 id="15-2-querydsl-장점">15.2. QueryDSL 장점</h3>

<ul>
<li>문자가 아닌 코드로 작성</li>
<li>컴파일 시점에 문법 오류 발견</li>
<li>코드 자동완성(IDE 도움)</li>
<li>단순하고 쉬움: 코드 모양이 JPQL과 거의 비슷</li>
<li>동적 쿼리</li>
</ul>

<h3 id="15-3-querydsl-사용">15.3. QueryDSL 사용</h3>

<ul>
<li>JPQL

<ul>
<li><code>select m from Member m where m.age &gt; 18</code></li>
</ul></li>
<li>QueryDSL</li>
</ul>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  JPAFactoryQuery query = <span style="color:#8b008b;font-weight:bold">new</span> JPAQueryFactory(em);
  QMember m = QMember.<span style="color:#658b00">member</span>;
  
  List&lt;Member&gt; list = query.<span style="color:#658b00">selectFrom</span>(m)
                           .<span style="color:#658b00">where</span>(m.<span style="color:#658b00">age</span>.<span style="color:#658b00">gt</span>(18))
                           .<span style="color:#658b00">orderBy</span>(m.<span style="color:#658b00">name</span>.<span style="color:#658b00">desc</span>())
                           .<span style="color:#658b00">fetch</span>();</code></pre></div>
<h3 id="15-4-querydsl-조인">15.4. QueryDSL - 조인</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">JPAQueryFactory query = <span style="color:#8b008b;font-weight:bold">new</span> JPAQueryFactory(em);
QMember m = QMember.<span style="color:#658b00">member</span>;
QTeam t = QTeam.<span style="color:#658b00">team</span>;

List&lt;Member&gt; list = query.<span style="color:#658b00">selectFrom</span>(m)
                         .<span style="color:#658b00">join</span>(m.<span style="color:#658b00">team</span>, t)
                         .<span style="color:#658b00">where</span>(t.<span style="color:#658b00">name</span>.<span style="color:#658b00">eq</span>(<span style="color:#cd5555">&#34;teamA&#34;</span>))
                         .<span style="color:#658b00">fetch</span>();</code></pre></div>
<h3 id="15-5-querydsl-페이징-api">15.5. QueryDSL - 페이징 API</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">JPAQueryFactory query = <span style="color:#8b008b;font-weight:bold">new</span> JPAQueryFactory(em);
QMember m = QMember.<span style="color:#658b00">member</span>;

List&lt;Member&gt; list = query.<span style="color:#658b00">selectFrom</span>(m)
                         .<span style="color:#658b00">orderBy</span>(m.<span style="color:#658b00">age</span>.<span style="color:#658b00">desc</span>())
                         .<span style="color:#658b00">offset</span>(10)
                         .<span style="color:#658b00">limit</span>(20)
                         .<span style="color:#658b00">fetch</span>();</code></pre></div>
<h3 id="15-6-querydsl-동적-쿼리">15.6. QueryDSL - 동적 쿼리</h3>

<blockquote>
<p>QueryDSL을 쓰는 가장 큰 이유는 동적 쿼리 때문</p>
</blockquote>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String name = <span style="color:#cd5555">&#34;memebr&#34;</span>;
<span style="color:#00688b;font-weight:bold">int</span> age = 9;

QMember m = QMember.<span style="color:#658b00">member</span>;

BooleanBuildere builder = <span style="color:#8b008b;font-weight:bold">new</span> BooleanBuilder();
<span style="color:#8b008b;font-weight:bold">if</span> (name != <span style="color:#8b008b;font-weight:bold">null</span>) {
  builder.<span style="color:#658b00">and</span>(m.<span style="color:#658b00">name</span>.<span style="color:#658b00">contains</span>(name));
}
<span style="color:#8b008b;font-weight:bold">if</span> (age != 0) {
  builder.<span style="color:#658b00">and</span>(m.<span style="color:#658b00">age</span>.<span style="color:#658b00">gt</span>(age);
}

List&lt;Member&gt; list = query.<span style="color:#658b00">selectFrom</span>(m)
                         .<span style="color:#658b00">where</span>(builder)
                         .<span style="color:#658b00">fetch</span>();</code></pre></div>
<p>특히 DTO로 바로 조회해야 하는 경우 QueryDSL이 특히 유용하다.</p>

<h3 id="15-7-querydsl-이것은-자바다">15.7. QueryDSL - 이것은 자바다!</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">return</span> query.<span style="color:#658b00">selectFrom</span>(coupon)
            .<span style="color:#658b00">where</span>(
                coupon.<span style="color:#658b00">type</span>.<span style="color:#658b00">eq</span>(typeParam),
                coupon.<span style="color:#658b00">status</span>.<span style="color:#658b00">eq</span>(<span style="color:#cd5555">&#34;LIVE&#34;</span>), <span style="color:#228b22">//서비스 필수 제약조건
</span><span style="color:#228b22"></span>                marketing.<span style="color:#658b00">viewCount</span>.<span style="color:#658b00">lt</span>(marketing.<span style="color:#658b00">maxCount</span>) <span style="color:#228b22">//서비스 필수 제약조건
</span><span style="color:#228b22"></span>             )
             .<span style="color:#658b00">fetch</span>();</code></pre></div>
<p>위와 같은 상황에서 다음과 같이 제약조건을 조립할 수 있다. (가독성과 재사용성 제고)</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">return</span> query.<span style="color:#658b00">selectFrom</span>(coupon)
            .<span style="color:#658b00">where</span>(
                coupon.<span style="color:#658b00">type</span>.<span style="color:#658b00">eq</span>(typeParam),
                isServiceable()
            )
            .<span style="color:#658b00">fetch</span>();

<span style="color:#8b008b;font-weight:bold">private</span> BooleanExpression <span style="color:#008b45">isServiceable</span>() {
    <span style="color:#8b008b;font-weight:bold">return</span> coupon.<span style="color:#658b00">status</span>.<span style="color:#658b00">eq</span>(<span style="color:#cd5555">&#34;LIST&#34;</span>) <span style="color:#228b22">//서비스 필수 제약조건
</span><span style="color:#228b22"></span>           .<span style="color:#658b00">and</span>(marketing.<span style="color:#658b00">viewCount</span>.<span style="color:#658b00">lt</span>(marketing.<span style="color:#658b00">maxCount</span>)); <span style="color:#228b22">//서비스 필수 제약조건
</span><span style="color:#228b22"></span>}</code></pre></div>
  </div>
  <footer>
    <div class="article-footer">
      

      
      
      
      
      
      <div id="pagenavigation-next-prev">
        
        <div id="pagenavigation-next">
          <span class="pagenav-label">&lt; 이전 글</span>
          <a href="http://integerous.github.io/post/java/abstract_class/">추상(abstract) 클래스가 필요한 기본적인 이유</a>
        </div>
        
        
        <div id="pagenavigation-prev">
          <span class="pagenav-label">다음 글 ></span>
          <a href="http://integerous.github.io/post/translated/pathvariable_queryparam/">[번역] Path Variable과 Query Parameter는 언제 사용해야 할까?</a>
        </div>
        
      </div>
      
    </div>

    <script src="https://utteranc.es/client.js"
    repo="integerous/blog-comments"
    issue-term="pathname"
    crossorigin="anonymous"
    async>
    </script>
  </footer>
</div>





</div>

</div>
<footer>
<div id="site-footer-wrap">
  <div id="site-footer">
    <span>Powered by <a href="https://gohugo.io/">Hugo</a>.</span>
    <span>
      
      Copyright (c) 2019, <a href="http://integerous.github.io/">Integerous DevLog</a>
      
    </span>
  </div>
</div>
</footer>
</div>
</body>
</html>