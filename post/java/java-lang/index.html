

<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZXLS88');</script>
    

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="Hugo 0.55.3" />
    <link rel="shortcut icon" href="/images/favicon.ico">
    <link href="http://integerous.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Integerous DevLog" />
    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
    
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:700i" rel="stylesheet">
    
    <script src="https://apis.google.com/js/platform.js" async defer>{lang: 'ja'}</script>
    
    <link rel="stylesheet" href="https://yandex.st/highlightjs/8.0/styles/default.min.css">
    <script src="https://yandex.st/highlightjs/8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <link rel="stylesheet" type="text/css" href="/css/single.css">
    <title>자바의 정석 - java.lang 패키지 | Integerous DevLog</title>
  </head>
  <body>
    
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KZXLS88"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  
    <div id="wrap">
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-126908369-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

      <header class="site-header">
        <div class="site-header-left">
          <a class="site-header-title" href="http://integerous.github.io/">Integerous DevLog</a>
        </div>
      </header>
      <div class="container">
        <div id="main">




<div class="article">
  <header>
    <div class="article-header">
      <h1>자바의 정석 - java.lang 패키지</h1>
      <div class="article-meta">
        <span class="posttime">2018/10/03</span>

        
        
<div class="tags">
  <ul>
    
    <li>
        <a href="/tags/java">Java</a>
    </li>
    
  </ul>
</div>


      </div>
    </div>
    
  </header>
  <div class="content">
    

<blockquote>
<p>자바의 정석(남궁성 저) 학습내용 정리</p>
</blockquote>

<h2 id="1-java-lang-패키지">1. java.lang 패키지</h2>

<ul>
<li>java.lang 패키지의 클래스들은 import문 없이도 사용 가능하다.</li>
</ul>

<h2 id="2-object-클래스">2. Object 클래스</h2>

<ul>
<li>Object 클래스는 모든 클래스의 최고 조상</li>
<li>Object 클래스의 멤버들은 모든 클래스에서 바로 사용 가능</li>
<li>Object 클래스는 멤버변수는 없고 11개의 메소드만 있다.</li>
</ul>

<blockquote>
<ul>
<li>protected Object <strong>clone()</strong> : 객체 자신의 복사본 반환<br /></li>
<li>public boolean <strong>equals(Object obj)</strong> : 객체 자신과 객체 obj가 같은 객체인지 판단</li>
<li>protected void <strong>finalize()</strong> : 객체가 소멸될 때 가비지콜렉터에 의해 자동으로 호출(거의 사용안함)</li>
<li>public Class <strong>getClasss()</strong> : 객체 자신의 클래스 정보를 담고 있는 Class 인스턴스를 반환</li>
<li>public int <strong>hashCode()</strong> : 객체 자신의 해시코드를 반환</li>
<li>public String <strong>toString()</strong> : 객체 자신의 정보를 문자열로 반환</li>
<li>public void <strong>notify()</strong> : 객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.</li>
<li>public void <strong>notifyAll()</strong> : 객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.</li>
<li>public void <strong>wait(long timeout, int nanos)</strong> : 다른 쓰레드가 notify()나 notifyAll()을 호출할 때 까지 현재 쓰레드를 무한히 또는 지정된 시간동안 기다리게 한다.</li>
</ul>
</blockquote>

<h2 id="3-equals-object-obj">3. equals(Object obj)</h2>

<ul>
<li>Object 클래스로부터 상속받은 equals 메소드는 두 개의 참조변수가 같은 객체를 참조하는지(두 참조변수에 저장된 주소값이 같은지) 판단</li>
<li>equals 메소드로 Value 인스턴스가 가지고 있는 value값을 비교하려면,<br />
Value 클래스에서 equals 메소드를 오버라이딩하여 주소가 아닌 객체에 저장된 내용을 비교하도록 변경해야 한다.</li>
</ul>

<h2 id="4-hashcode">4. hashCode()</h2>

<ul>
<li>해시함수는 찾는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드(hash code)를 반환한다.</li>
<li>일반적으로 해시코드가 같은 두 객체가 존재하는 것이 가능하지만,<br />
Object 클래스에 정의된 hashCode 메소드는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에<br />
서로 다른 두 객체는 같은 해시코드를 가질 수 없다.</li>
<li>String 클래스는 문자열의 내용이 같으면 같은 해시코드를 반환하도록 hashCode메소드가 오버라이딩 되어 있기 때문에<br />
문자열의 내용이 같은 str1과 str2에 대해 hashCode()를 호출하면 항상 동일한 해시코드 값을 얻는다.</li>
</ul>

<h2 id="5-tostring">5. toString()</h2>

<ul>
<li>Object 클래스에 정의된 toString()
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> String <span style="color:#008b45">toString</span>()  {
    <span style="color:#8b008b;font-weight:bold">return</span> getClass().<span style="color:#658b00">getName</span>()+<span style="color:#cd5555">&#34;@&#34;</span>+Integer.<span style="color:#658b00">toHexString</span>(hashCode());
}</code></pre></div></li>
<li>클래스를 작성할 때 toString()을 오버라이딩 하지 않고, toString()을 호출하면 클래스이름+16진수의 해시코드를 반환한다.</li>
<li>String 클래스의 toString()은 String 인스턴스가 갖고 있는 문자열을 반환하도록 오버라이딩 되어 있다.</li>
<li>Date 클래스의 경우, Date 인스턴스가 갖고 있는 날짜와 시간을 문자열로 반환하도록 오버라이딩 되어 있다.</li>
</ul>

<h2 id="6-clone">6. clone()</h2>

<ul>
<li>자신을 복제하여 새로운 인스턴스를 생성한다.</li>
<li>Object 클래스에 정의된 clone()은 단순히 인스턴스 변수의 값만 복사하기 때문에<br />
참조타입의 인스턴스 변수가 있는 클래스는 완전한 인스턴스 복제가 이루어지지 않는다.</li>
<li>clone()은 반드시 예외처리를 해줘야 한다.</li>
</ul>

<h2 id="7-공변-반환타입-covariant-return-type">7. 공변 반환타입 (covariant return type)</h2>

<ul>
<li>JDK1.5부터 오버라이딩할 때 부모 메소드의 반환타입을 자식 클래스의 타입으로 변경 가능하다.
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> Point <span style="color:#008b45">clone</span>()  { <span style="color:#228b22">// 반환타입을 Object에서 Point로 변경
</span><span style="color:#228b22"></span>    Object obj = <span style="color:#8b008b;font-weight:bold">null</span>;
    <span style="color:#8b008b;font-weight:bold">try</span> {
    obj = <span style="color:#8b008b;font-weight:bold">super</span>.<span style="color:#658b00">clone</span>();
    } <span style="color:#8b008b;font-weight:bold">catch</span>(CloneNotSupportedException e) {}
    <span style="color:#8b008b;font-weight:bold">return</span> (Point)obj; //Point 타입으로 형변환</code></pre></div></li>
<li>공변 반환타입을 사용하면 조상의 타입이 아닌, 실제로 반환되는 자손 객체의 타입으로 반환할 수 있어 번거로운 형변환이 줄었다.

<ul>
<li><code>Point copy = (Point)original.clone();</code> -&gt; <code>Point copy = original.clone();</code></li>
</ul></li>
</ul>

<h2 id="8-배열-복사">8. 배열 복사</h2>

<ul>
<li>배열도 객체이기 때문에 Object 클래스를 상속받으며, 동시에 Cloneable 인터페이스와 Serializable 인터페이스가 구현되어 있다.</li>
<li>일반적으로 배열을 복사할 때는 같은 길이의 새로운 배열을 생성한 다음 <code>System.arraycopy()</code>를 이용해서 내용을 복사하지만 <code>clone()</code>을 이용해서 간단하게 복사할 수 있다.

<ul>
<li><div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#00688b;font-weight:bold">int</span>[] arr = {1,2,3,4,5};
<span style="color:#00688b;font-weight:bold">int</span>[] arrClone = arr.<span style="color:#658b00">clone</span>();</code></pre></div></li>
<li><div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#00688b;font-weight:bold">int</span>[] arr = {1,2,3,4,5};
<span style="color:#00688b;font-weight:bold">int</span>[] arrClone = <span style="color:#8b008b;font-weight:bold">new</span> <span style="color:#00688b;font-weight:bold">int</span>[arr.<span style="color:#658b00">length</span>];
System.<span style="color:#658b00">arraycopy</span>(arr,0,arrClone,0,arr.<span style="color:#658b00">length</span>);</code></pre></div></li>
</ul></li>
<li>배열 뿐만 아니라 <code>java.util</code> 패키지의</li>
</ul>

<blockquote>
<p>Vector<br />
ArrayList<br />
LinkedList<br />
HashSet<br />
TreeSet<br />
HashMap<br />
TreeMap<br />
Calendar<br />
Date와 같은 클래스들도 복제가 가능하다.</p>
</blockquote>

<h2 id="9-얕은-복사와-깊은-복사-shallow-copy-deep-copy">9. 얕은 복사와 깊은 복사 (shallow copy &amp; deep copy)</h2>

<ul>
<li>clone()은 객체에 저장된 값을 그대로 복제할 뿐, 객체가 참조하고 있는 객체까지 복제하지 않음

<ul>
<li>원본과 복제본이 같은 객체를 참조</li>
<li>이것이 얕은 복사(shallow copy)</li>
<li>얕은 복사에서는 원본을 변경하면 복사본도 영향을 받는다.</li>
</ul></li>
<li>원본이 참조하고 있는 객체까지 복제하는 것이 깊은 복사(deep copy)

<ul>
<li>원본과 복사본이 서로 다른 객체를 참조하기 때문에 원본의 변경이 복사본에 영향 없음
<br /></li>
</ul></li>
</ul>

<h2 id="10-getclass">10. getClass()</h2>

<ul>
<li>자신이 속한 클래스의 Class 객체를 반환하는 메소드</li>
<li>Class 객체는 이름이 &lsquo;Class&rsquo;인 클래스의 객체이다.
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">final</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Class</span> <span style="color:#8b008b;font-weight:bold">implements</span> ... {
  ...
}</code></pre></div></li>
<li>Class 객체는 클래스의 모든 정보를 담고 있으며, 클래스 당 1개만 존재한다.</li>
<li>클래스 파일이 &lsquo;ClassLoader&rsquo;에 의해 메모리에 올라갈 때 자동으로 생성

<ul>
<li>파일 형태로 저장되어 있는 클래스를 읽어서 Class클래스에 정의된 형식으로 변환하는 것</li>
<li>즉, 클래스 파일을 읽어서 사용하기 편한 형태로 저장한 것이 클래스 객체</li>
</ul></li>
<li>Class 객체 얻는 방법

<ul>
<li><code>Class cObj = new Card().getClass(); // 생성된 객체로 부터 얻기</code></li>
<li><code>Class cObj = Card.class; // 클래스 리터럴(*.class)로 부터 얻기</code></li>
<li><code>Class cObj = Class.forName(&quot;Card&quot;); //클래스 이름으로 부터 얻기</code></li>
</ul></li>
<li>객체 생성

<ul>
<li><code>Card c = new Card(); // new연산자로 객체 생성</code></li>
<li><code>Card c = Card.class.newInstance(); // Class객체로 객체 생성</code></li>
</ul></li>
</ul>

<h2 id="11-string-클래스">11. String 클래스</h2>

<ul>
<li>String 클래스는 문자열을 저장하기 위해 문자형 배열 변수(char[]) value를 인스턴스 변수로 정의되어있다.
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">final</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">String</span> <span style="color:#8b008b;font-weight:bold">implements</span> java.<span style="color:#658b00">io</span>.<span style="color:#658b00">Serializable</span>, Comparable {
    <span style="color:#8b008b;font-weight:bold">private</span> <span style="color:#00688b;font-weight:bold">char</span>[] value;
    ...
}</code></pre></div></li>
<li>인스턴스 생성 시 생성자의 매개변수로 입력받는 문자열은 인스턴스 변수 <code>value</code>에 문자형 배열 <code>char[]</code>로 저장되는 것이다.</li>
<li>String 클래스는 앞에 final이 붙어 있으므로 다른 클래스의 부모가 될 수 없다.</li>
<li>변경 불가능한(Immutable) 클래스다.

<ul>
<li>예를 들어 &lsquo;+&rsquo; 연산자를 이용해서 문자열을 결합하는 경우, 인스턴스 내의 문자열이 바뀌는 것이 아니라 새로운 문자열이 담긴 String 인스턴스가 생성되는 것이다.</li>
<li>즉, 매 연산 마다 새로운 문자열을 가진 String 인스턴스가 생성되어 메모리 공간을 차지한다.</li>
</ul></li>
</ul>

<h3 id="11-1-문자열을-만드는-방법-2가지">11.1. 문자열을 만드는 방법 2가지</h3>

<ul>
<li><code>String str1 = &quot;abc&quot;;</code> // 문자열 리터럴 &ldquo;abc&rdquo;의 주소를 str1에 저장</li>
<li><code>String str2 = new String(&quot;abc&quot;);</code> // 새로운 String 인스턴스 생성</li>
<li>문자열 리터럴은 이미 존재하는 것을 재사용 하는 것이다. (문자열 리터럴은 클래스가 메모리에 로드될 때 자동으로 미리 생성된다.)</li>
<li><div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String str1 = <span style="color:#cd5555">&#34;abc&#34;</span>;
String str2 = <span style="color:#cd5555">&#34;abc&#34;</span>;
str1 == str2 ? <span style="color:#8b008b;font-weight:bold">true</span>
str1.<span style="color:#658b00">equals</span>(str2) ? <span style="color:#8b008b;font-weight:bold">true</span>

String str3 = <span style="color:#8b008b;font-weight:bold">new</span> String(<span style="color:#cd5555">&#34;abc&#34;</span>);
String str4 = <span style="color:#8b008b;font-weight:bold">new</span> String(<span style="color:#cd5555">&#34;abc&#34;</span>);
str3 == str4 ? <span style="color:#8b008b;font-weight:bold">false</span>
str3.<span style="color:#658b00">equals</span>(str4) ? <span style="color:#8b008b;font-weight:bold">true</span></code></pre></div></li>
</ul>

<h3 id="11-2-문자열-리터럴">11.2. 문자열 리터럴</h3>

<ul>
<li>클래스 파일에는 소스파일에 포함된 모든 리터럴의 목록이 있다.</li>
<li>해당 클래스 파일이 클래스 로더에 의해 메모리에 올라갈 때, 리터럴 목록에 있는 리터럴들이 JVM내에 있는 상수 저장소(constant pool)에 저장된다.</li>
</ul>

<h3 id="11-3-빈-문자열">11.3. 빈 문자열</h3>

<ul>
<li>길이가 0인 배열은 존재한다.(C언어는 불가능)</li>
<li>char형 배열도 길이가 0인 배열 생성할 수 있고, 이 배열을 내부적으로 가지고 있는 문자열이 빈 문자열이다.</li>
<li><code>String s = &quot;&quot;;</code> 에서 참조변수 <code>s</code>가 참조하고 있는 String 인스턴스는 내부에 <code>new char[0]</code> 같이 길이가 0인 char형 배열을 저장하고 있는 것이다.</li>
<li><code>char[] chArr = new char[0];</code></li>
<li><code>int[] iArr = {};</code></li>
</ul>

<h3 id="11-4-join-과-stringjoiner-jdk1-8부터-추가">11.4. <code>join()</code>과 <code>StringJoiner</code> (jdk1.8부터 추가)</h3>

<ul>
<li><code>join()</code>은 문자열 사이에 구분자를 넣어서 결합
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String[] arr = { <span style="color:#cd5555">&#34;dog&#34;</span>, <span style="color:#cd5555">&#34;cat&#34;</span>, <span style="color:#cd5555">&#34;bear&#34;</span>};
String str = String.<span style="color:#658b00">join</span>(<span style="color:#cd5555">&#34;-&#34;</span>, arr);</code></pre></div></li>
<li><code>java.util.StringJoiner</code>클래스 사용하여 문자열 결합
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">StringJoiner sj = <span style="color:#8b008b;font-weight:bold">new</span> StringJoiner(<span style="color:#cd5555">&#34;,&#34;</span> , <span style="color:#cd5555">&#34;[&#34;</span> , <span style="color:#cd5555">&#34;]&#34;</span>);
String[] strArr = { <span style="color:#cd5555">&#34;aaa&#34;</span>, <span style="color:#cd5555">&#34;bbb&#34;</span>, <span style="color:#cd5555">&#34;ccc&#34;</span> };

<span style="color:#8b008b;font-weight:bold">for</span>(String s : strArr)
    sj.<span style="color:#658b00">add</span>(s.<span style="color:#658b00">toUpperCase</span>());

System.<span style="color:#658b00">out</span>.<span style="color:#658b00">println</span>(sj.<span style="color:#658b00">toString</span>()); // [AAA,BBB,CCC]</code></pre></div></li>
</ul>

<h3 id="11-5-기본형-string-변환">11.5. 기본형-String 변환</h3>

<ul>
<li>숫자에 빈문자열(&ldquo;&rdquo;) 더하기</li>
<li><code>valueOf()</code> 사용</li>
<li><div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String str1 = 100 + <span style="color:#cd5555">&#34;&#34;</span>; <span style="color:#228b22">// 100 &gt; &#34;100&#34;
</span><span style="color:#228b22"></span>String str2 = String.<span style="color:#658b00">valueOf</span>(100); <span style="color:#228b22">// 100 &gt; &#34;100&#34;
</span><span style="color:#228b22"></span><span style="color:#00688b;font-weight:bold">int</span> i = Integer.<span style="color:#658b00">parseInt</span>(<span style="color:#cd5555">&#34;100&#34;</span>) <span style="color:#228b22">// &#34;100&#34; &gt; 100
</span><span style="color:#228b22"></span><span style="color:#00688b;font-weight:bold">int</span> i2 = Integer.<span style="color:#658b00">valueOf</span>(<span style="color:#cd5555">&#34;100&#34;</span>) // <span style="color:#cd5555">&#34;100&#34;</span> &gt; 100</code></pre></div></li>
<li>valueOf()의 반환타입은 int가 아니라 Integer지만 오토박싱에 의해 자동변환</li>
<li><code>valueOf(String s)</code> 는 메소드 내부에 <code>parseInt(String s)</code>를 호출할 뿐이므로, 두 메소드는 반환 타입만 다르고 같은 메소드다.</li>
</ul>

<h2 id="12-stringbuffer-stringbuilder-클래스">12. StringBuffer &amp; StringBuilder 클래스</h2>

<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">final</span> <span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">StringBuffer</span> <span style="color:#8b008b;font-weight:bold">implements</span> java.<span style="color:#658b00">io</span>.<span style="color:#658b00">Serializable</span> {
    <span style="color:#8b008b;font-weight:bold">private</span> <span style="color:#00688b;font-weight:bold">char</span>[] value;
    ...
}</code></pre></div>

<ul>
<li>String클래스는 Immutable이므로 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만, StringBuffer클래스는 가능하다.</li>
<li>내부적으로 문자열 편집을 위한 buffer를 가지고 있으며, StringBuffer 인스턴스를 생성할 때 그 크기를 지정할 수 있다.</li>
<li>buffer의 크기를 지정하지 않으면 16개의 문자를 저장할 수 있는 크기의 버퍼 생성</li>
</ul>

<h3 id="12-1-append">12.1 append()</h3>

<ul>
<li><code>append()</code>는 반환타입이 StringBuffer이며 자신의 주소를 반환한다.
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  StringBuffer sb = <span style="color:#8b008b;font-weight:bold">new</span> StringBuffer(<span style="color:#cd5555">&#34;abc&#34;</span>);
  sb.<span style="color:#658b00">append</span>(<span style="color:#cd5555">&#34;123&#34;</span>).<span style="color:#658b00">append</span>(<span style="color:#cd5555">&#34;ZZ&#34;</span>);
  </code></pre></div></li>
<li>위의 코드에서 <code>sb.append(&quot;123&quot;)</code>이 <code>sb</code>를 반환하므로 연속적으로 append()를 호출할 수 있다.</li>
<li>StringBuffer 클래스는 equals() 메소드를 오버라이딩 하지 않아서 <code>==</code>로 비교한 것과 같은 결과를 얻는다.</li>
<li>StringBuffer 인스턴스에 담긴 문자열을 비교하기 위해서는 인스턴스에 <code>toString()</code>을 호출해서 String인스턴스를 얻은 후에 <code>equals()</code>사용해야 한다.</li>
</ul>

<h3 id="12-2-stringbuilder-클래스">12.2. StringBuilder 클래스</h3>

<ul>
<li>StringBuffer는 멀티쓰레드에 안전(thread safe)하도록 동기화 되어있다.</li>
<li>동기화가 StringBuffer의 성능을 떨어트리므로, StringBuffer에서 쓰레드의 동기화만 뺀 것이 StringBuilder.</li>
</ul>

<h2 id="13-java-util-random-클래스">13. java.util.Random 클래스</h2>

<ul>
<li><code>Math.random()</code>은 내부적으로 Random클래스의 인스턴스를 생성해서 사용한다.</li>
<li><code>Math.random()</code>과 <code>Random</code>의 가장 큰 차이는 종자값(seed)을 설정할 수 있다는 것이다.</li>
<li>종자값이 같은 <code>Random</code>인스턴스들은 항상 같은 난수를 같은 순서대로 반환</li>
<li>생성자 <code>Random()</code>은 종자값을 <code>System.currentTimeMillis()</code>로 하기 때문에 실행할 때마다 얻는 난수가 달라진다.</li>
</ul>

<h2 id="14-java-util-stringtokenizer-클래스">14. java.util.StringTokenizer 클래스</h2>

<ul>
<li>StringTokenizer는 긴 문자열을 지정된 구분자(delimeter)를 기준으로 토큰(token)이라는 여러 개의 문자열로 잘라내는 데 사용</li>
<li>StringTokenizer는 구분자로 단 하나의 문자만 사용 가능하기 때문에 복잡한 형태의 구분자는 정규식을 사용해야 한다.</li>
<li><code>StringTokenizer (String str, String delim, boolean returnDelims)</code> - returnDelims 값을 true로 하면 구분자도 토큰으로 간주한다.</li>
<li><code>split()</code>은 빈 문자열도 토큰으로 인식, StringTokenizer는 빈 문자열을 토큰으로 인식 안함</li>
<li><code>split()</code>은 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환</li>
<li>StringTokenizer는 데이터를 토큰으로 바로바로 잘라서 반환하므로 <code>split()</code>보다 성능 좋음</li>
</ul>

<h3 id="14-1-한글로-된-숫자를-아라비아-숫자로-변환">14.1. 한글로 된 숫자를 아라비아 숫자로 변환</h3>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8b008b;font-weight:bold">import</span> <span style="color:#008b45;text-decoration:underline">java.util.*</span>;

<span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">StringTokenizer</span> {
  <span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">main</span>(String args[])  {
    String input = <span style="color:#cd5555">&#34;삼십만삼천백십오&#34;</span>;
    System.<span style="color:#658b00">out</span>.<span style="color:#658b00">println</span>(input); <span style="color:#228b22">// 삼십만삼천백십오
</span><span style="color:#228b22"></span>    System.<span style="color:#658b00">out</span>.<span style="color:#658b00">println</span>(hangulToNum(input)); <span style="color:#228b22">// 303115
</span><span style="color:#228b22"></span>  }
  
  <span style="color:#8b008b;font-weight:bold">public</span> <span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">long</span> <span style="color:#008b45">hangulToNum</span>(String input)  {
    <span style="color:#00688b;font-weight:bold">long</span> result = 0;  <span style="color:#228b22">// 최종 변환결과를 저장하기 위한 변수
</span><span style="color:#228b22"></span>    <span style="color:#00688b;font-weight:bold">long</span> tmpResult = 0; <span style="color:#228b22">// 십백천 단위의 값을 저장하기 위한 임시변수
</span><span style="color:#228b22"></span>    <span style="color:#00688b;font-weight:bold">long</span> num = 0;
    
    <span style="color:#8b008b;font-weight:bold">final</span> String NUMBER = <span style="color:#cd5555">&#34;영일리삼사오육칠팔구&#34;</span>;
    <span style="color:#8b008b;font-weight:bold">final</span> String UNIT = <span style="color:#cd5555">&#34;십백천만억조&#34;</span>;
    <span style="color:#8b008b;font-weight:bold">final</span> <span style="color:#00688b;font-weight:bold">long</span>[] UNIT_NUM = {10,100,1000,10000,(<span style="color:#00688b;font-weight:bold">long</span>)1e8,(<span style="color:#00688b;font-weight:bold">long</span>)1e12};
    
    StringTokenizer st = <span style="color:#8b008b;font-weight:bold">new</span> StringTokenizer(input, UNIT, <span style="color:#8b008b;font-weight:bold">true</span>);
    
    <span style="color:#8b008b;font-weight:bold">while</span>(st.<span style="color:#658b00">hasMoreTokens</span>()) {
      String token = st.<span style="color:#658b00">nextToken</span>();
      <span style="color:#00688b;font-weight:bold">int</span> check = NUMBER.<span style="color:#658b00">indexOf</span>(token);  <span style="color:#228b22">// 숫자인지, 단위(UNIT)인지 확인
</span><span style="color:#228b22"></span>      
      <span style="color:#8b008b;font-weight:bold">if</span>(check == -1) {
        <span style="color:#8b008b;font-weight:bold">if</span>(<span style="color:#cd5555">&#34;만억조&#34;</span>.<span style="color:#658b00">indexOf</span>(token) == -1) {
          tmpResult += ( num!=0 ? num : 1) * UNIT_NUM[UNIT.<span style="color:#658b00">indexOf</span>(token)];
        }<span style="color:#8b008b;font-weight:bold">else</span> {
          tmpResult += num;
          result += (tmpResult!=0 ? tmpResult : 1)
           * UNIT_NUM[UNIT.<span style="color:#658b00">indexOf</span>(token)];
          tmpResult = 0;
        }
        num = 0;
      }<span style="color:#8b008b;font-weight:bold">else</span> {
        num = check;
      }
    }
    <span style="color:#8b008b;font-weight:bold">return</span> result + tmpResult + num;
  }
}</code></pre></div>
  </div>
  <footer>
    <div class="article-footer">
      

      
      
      
      
      
      <div id="pagenavigation-next-prev">
        
        <div id="pagenavigation-next">
          <span class="pagenav-label">&lt; 이전 글</span>
          <a href="http://integerous.github.io/post/java/java-calendar-date/">자바의 정석 - 날짜와 시간(Calendar와 Date, java.time패키지)</a>
        </div>
        
        
        <div id="pagenavigation-prev">
          <span class="pagenav-label">다음 글 ></span>
          <a href="http://integerous.github.io/post/java/java-exception/">자바의 정석 - 예외 처리(Exception handling)</a>
        </div>
        
      </div>
      
    </div>

    <script src="https://utteranc.es/client.js"
    repo="integerous/blog-comments"
    issue-term="pathname"
    crossorigin="anonymous"
    async>
    </script>
  </footer>
</div>





</div>

</div>
<footer>
<div id="site-footer-wrap">
  <div id="site-footer">
    <span>Powered by <a href="https://gohugo.io/">Hugo</a>.</span>
    <span>
      
      Copyright (c) 2021, <a href="http://integerous.github.io/">Integerous DevLog</a>
      
    </span>
  </div>
</div>
</footer>
</div>
</body>
</html>